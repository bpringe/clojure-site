= Getting Started with Clojure on Windows
Brandon Ringe
2019-10-19
:type: guides 
:toc: macro
:icons: font

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

While there are different approaches and tooling stacks that can be used with Clojure, this guide serves as a specific approach designed to reduce friction for beginners. The tools used in this guide are the following:

* Leiningen (pronounced LINE-ing-en) - This is like a package manager, build tool, task manager, and more in one tool. Think npm or nuget, but with more capabilities. There is at least one other build tool for Clojure (boot), but Leiningen is the most widely used.

* JDK - Clojure runs on the Java Virtual Machine (JVM). Throw out any qualms you may have about Java, we aren't coding in Java (though we can through Clojure, and sometimes that can be useful).

* IDE - We'll be using Visual Studio Code for our editor, with the Calva extension for Clojure support.

We can actually install those first two in one go with Chocolatey, a package manager for Windows. They can be installed other ways of course, but this way is simple and easy.

== Install Lineingen and the JDK

First, if you don't already have Chocolatey installed, follow the installation instructions at https://chocolatey.org/[chocolatey.org]. Once it's installed, open a shell or CMD terminal with admin priviledges and run the following:

[source,shell]
----
choco install lein
----

You'll notice the Chocolatey package installs the OpenJDK and Leiningen. Let's start a REPL (read, eval, print loop).

[source,shell]
----
lein repl
----

NOTE: If you see a message that 'java' is not recognized as a command, close your terminal and reopen it, then try again.

You should see something beautiful like the following:

[source,shell]
----
Î» lein repl
nREPL server started on port 52599 on host 127.0.0.1 - nrepl://127.0.0.1:52599
REPL-y 0.4.3, nREPL 0.6.0
Clojure 1.10.0
OpenJDK 64-Bit Server VM 12.0.2+10
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=>
----

Clojure awaits you. Let's try simple addition:

[source,shell]
----
user=> (+ 1 2 3)
6
----

Now we're in business! Hit `ctrl+D` to exit the REPL. Let's get our editor set up.

== Calva and VS Code

If you don't already have https://code.visualstudio.com/[VS Code], go ahead and install it. Then let's create a project with lein. In your terminal, run:

[source,shell]
----
lein new clojure-project
----

This will create a project in a new directory named `clojure-project`. Let's open that directory in VS Code.

[source,shell]
----
code clojure-project
----

Now that we have this fresh new Clojure project, let's install Calva. In VS Code, go to Extensions and search "Calva" - install it. Now open the `core.clj` file in the `src/clojure_project` directory of your project, and hit the shortcut keys `ctrl+alt+c, ctrl+alt+j` to run the Calva jack-in command, select `Leiningen` as the project type when prompted. This starts a project REPL and connects Calva to it, and gives you a sweet REPL window in VS Code to work in. This is a souped-up version of what you saw in your terminal.

NOTE: There's a convenient feature of Calva that you should turn on, at least for the rest of this tutorial. Go into your VS Code Settings, then go to Extensions -> Calva and check the box next to "Eval On Save." This will ensure your code is compiled as you save your file, so you can immediately try it out in your REPL.

Notice at the top of your `core.clj` file that you're in the `clojure-project.core` namespace (`ns` is the namespace function). All Clojure functions and vars live inside of namespaces, and usually code is organized as one namespace per file. The namespace your REPL started in is the `user` namespace. Let's switch it to the `clojure-project.core` namespace so we can run code from that namespace/file. Type the shortcut keys `ctrl+alt+c, ctrl+alt+n` to switch the the current namespace (of the opened file).

You should see the prompt in your REPL window changed to `clojure-project.core=>`, indicating that your REPL is now in that namespace. Calva was also nice enough to compile that namespace when we switched to it, so let's run that `foo` function that was generated by Leiningen. In your REPL, type:

[source,clojure]
----
(foo "test")
----

Then hit `alt+enter`. You can also just hit `enter` if your cursor is at the end of the line. You should see that it printed the message from the function. Change the contents of the message, save the file, and run `foo` again in your REPL. You should see the changes. Pretty fast development cycle, right? It makes working in Clojure a pretty fun experience.

== Using Comment Forms for Testing

Another useful thing you can do is eval the current form (expression inside parentheses), or the top level form, which is another command, and have the result printed inside your editor as an annotation. You can also send the form to the REPL window to be evaluated. This is useful to quickly run a small bit of code from the editor as you're developing.

Something you can also do when testing code is use Clojure's `comment` function to create a comment block, then add all your test calls inside the comment block. This way the function calls won't occur on file save (if Eval On Save is turned on), and you can send them one by one to the REPL, or evaluate them in the editor. Then when you return later you have the sequence of calls saved in a file.

[source,clojure]
----
(comment
   ;;;; These can be eval'd individually in the editor or in the REPL

   (foo "test")

   (println "hello Clojure")

   (+ 1 2 3))
----

You should try out Calva's many different commands. Hit `ctrl+shift+p` and type "calva" to see a list of all its commands.
